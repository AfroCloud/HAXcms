<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">
<link rel="import" href="../paper-progress/paper-progress.html">

<!--
`haxcms-site-builder`
A LRN element

@demo demo/index.html

@microcopy - the mental model for this element
 - This is a factory element, it doesn't do much on its own visually
 - it loads a site.json file and then utilizes this data in order to construct
   what theme it should load (element) in order to get everything off and running

-->

<dom-module id="haxcms-site-builder">
  <template>
    <style>
      :host {
        display: block;
      }
      :host #slot {
        background-color: white;
        opacity: .2;
        transition: all 1s linear;
        visibility: hidden;
      }
      :host[loading] #slot {
        opacity: .8;
      }
      :host[theme-loaded] #slot {
        opacity: 1;
        visibility: visible;
      }
      paper-progress {
        display: block;
        width: 100%;
        --paper-progress-active-color: rgba(255, 255, 255, 0.5);
        --paper-progress-container-color: transparent;
      }
    </style>
    <paper-progress hidden$="[[!loading]]" value="100" indeterminate bottom-item></paper-progress>
    <iron-ajax
     id="manifest"
     url="[[outlineLocation]][[file]][[__timeStamp]]"
     handle-as="json"
     last-response="{{manifest}}"></iron-ajax>
    <iron-ajax
     id="activecontent"
     url="[[outlineLocation]][[activeItem.location]][[__timeStamp]]"
     handle-as="text"
     loading="{{loading}}"
     debounce-duration="250"
     last-response="{{_activeItemContent}}"></iron-ajax>
    <div id="slot">
      <slot></slot>
    </div>
  </template>
  <script>
    Polymer({
      is: 'haxcms-site-builder',
      properties: {
        /**
         * Loading status of the page to render.
         */
        loading: {
          type: Boolean,
          value: false,
          reflectToAttribute: true,
        },
        /**
         * support for alternate locations.
         */
        outlineLocation: {
          type: String,
        },
        /**
         * Manifest from file
         */
        manifest: {
          type: Object,
          notify: true,
          observer: '_manifestChanged',
        },
        /**
         * Theme, used to boot a design element
         */
        themeElementName: {
          type: String,
          reflectToAttribute: true,
          observer: '_themeChanged',
        },
        /**
         * Theme, used to boot a design element
         */
        themeElement: {
          type: Object,
        },
        /**
         * registry to map theme names to locations
         */
        themeData: {
          type: Object,
          value: {
            "outline-player": "../outline-player/outline-player.html",
            "simple-blog": "../simple-blog/simple-blog.html",
            "infinite-scroll-site": "../infinite-scroll-site/infinite-scroll-site.html",
          },
        },
        /**
         * Imported items so we can allow theme flipping dynamically
         */
        __imported: {
          type: Object,
          value: {},
        },
        /**
         * theme loaded to indicate to the theme we have a theme ready to go
         */
        themeLoaded: {
          type: Boolean,
          reflectToAttribute: true,
          value: false,
        },
        /**
         * Active item which is in JSON Outline Schema
         */
        activeItem: {
          type: Object,
          notify: true,
          observer: '_activeItemChanged',
        },
        /**
         * Active item content
         */
        _activeItemContent: {
          type: String,
          observer: '_activeItemContentChanged',
        },
        /**
         * Location of the site.json file
         */
        file: {
          type: String,
          observer: '_fileChanged',
        },
      },
      /**
       * Attached life cycle
       */
      attached : function () {
        document.body.addEventListener('haxcms-trigger-update', this._triggerUpdatedData.bind(this));
        document.body.addEventListener('json-outline-schema-active-item-changed', this._setActiveItem.bind(this));
      },
      /**
       * set global active item
       */
      _setActiveItem: function (e) {
        this.set('activeItem', e.detail);
      },
      /**
       * React to content being loaded from a page.
       */
      _activeItemContentChanged: function (newValue, oldValue) {
        if (newValue) {
          // only append if not empty
          if (newValue !== null) {
            let frag = document.createRange().createContextualFragment(newValue);
            Polymer.dom(this.themeElement).appendChild(frag);
          }
          this.fire('json-outline-schema-active-body-changed', newValue);
        }
      },
      /**
       * Wipe slotted content
       */
      wipeSlot: function (element, slot = '*') {
        // 100% clean slate
        if (slot === '*') {
          while (Polymer.dom(element).firstChild !== null) {
            Polymer.dom(element).removeChild(Polymer.dom(element).firstChild);
          }
        }
        else {
          for (var i in Polymer.dom(element).childNodes) {
            // test for element nodes to be safe
            if (typeof Polymer.dom(element).childNodes[i] !== typeof undefined && Polymer.dom(element).childNodes[i].slot === slot) {
              Polymer.dom(element).removeChild(Polymer.dom(element).childNodes[i]);
            }
          }
        }
      },
      /**
       * Active item updated, let's request the content from it
       */
      _activeItemChanged: function (newValue, oldValue) {
        if (newValue) {
          this.wipeSlot(this.themeElement, '*');
          this.$.activecontent.generateRequest();
        }
      },
      /**
       * got a message that we need to update our json manifest data
       */
      _triggerUpdatedData: function (e) {
        // append a value so we know we get fresher data
        this.__timeStamp = '?' + (Math.floor(Date.now() / 1000));
        this.$.manifest.generateRequest();
      },
      /**
       * File changed so let's pull from the location
       */
      _fileChanged: function (newValue, oldValue) {
        if (typeof newValue !== typeof undefined) {
          this.$.manifest.generateRequest();
        }
      },
      /**
       * notice theme changes and ensure slot is rebuilt.
       */
      _manifestChanged: function (newValue, oldValue) {
        if (typeof newValue !== typeof undefined && typeof newValue.id !== typeof undefined) {
          this.themeElementName = newValue.metadata.theme;
          Polymer.cmsSiteEditor.jsonOutlineSchema = newValue;
          this.fire('json-outline-schema-changed', newValue);  
        }
      },
      /**
       * notice theme changes and ensure slot is rebuilt.
       */
      _themeChanged: function (newValue, oldValue) {
        if (newValue && oldValue) {
          Polymer.cmsSiteEditor.instance.appendChild(Polymer.cmsSiteEditor.instance.haxCmsSiteEditorElement);
        }
        if (newValue) {
          this.themeLoaded = false;
          var themeName = newValue;
          // trap for blowing up the world ;)
          if (typeof this.themeData[themeName] === typeof undefined) {
            console.log('HAXCMS developer: ' + themeName + ' is not a valid theme name');
            this.themeElementName = 'simple-blog';
            return false;
          }
          // wipe out what we got
          this.wipeSlot(this, '*');
          // create the 'theme' as a new element
          this.themeElement = document.createElement(themeName);
          // give it our manifest
          this.themeElement.manifest = this.manifest;
          // weird but definition already here so we should be able
          // to just use this without an import, it's possible..
          if (typeof this.__imported[themeName] !== typeof undefined) {
            Polymer.dom(this).appendChild(this.themeElement);
            this.themeLoaded = true;
          }
          else {
            // import the reference to the item dynamically, if we can
            try {
              this.importHref(this.resolveUrl(this.themeData[themeName]), (e) => {
                // add it into ourselves so it unpacks and we kick this off!
                Polymer.dom(this).appendChild(this.themeElement);
                this.__imported[themeName] = themeName;
                this.themeLoaded = true;
              });
            }
            catch (err) {
              // error in the event this is a double registration
              // also strange to be able to reach this but technically possible
              Polymer.dom(this).appendChild(this.themeElement);
              this.themeLoaded = true;
            }
          }
        }
      },
      /**
       * Wipe slotted content
       */
      wipeSlot: function (element, slot = '*') {
        // 100% clean slate
        if (slot === '*') {
          while (Polymer.dom(element).firstChild !== null) {
            Polymer.dom(element).removeChild(Polymer.dom(element).firstChild);
          }
        }
        else {
          for (var i in Polymer.dom(element).childNodes) {
            // test for element nodes to be safe
            if (typeof Polymer.dom(element).childNodes[i] !== typeof undefined && Polymer.dom(element).childNodes[i].slot === slot) {
              Polymer.dom(element).removeChild(Polymer.dom(element).childNodes[i]);
            }
          }
        }
      },
    });
  </script>
</dom-module>